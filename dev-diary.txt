TODOs:
    * figure out how to set up type annotations
    * figure out how to set up rubocop in vscode (extension doesn't seem to like my rbenv setup)

https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/

"There is good support for functional programming with first-class functions, anonymous functions, and closures."
    :)

"You never directly access attributes. With Ruby, it‚Äôs all method calls."
"Parentheses for method calls are usually optional."
    :(

"There‚Äôs public, private, and protected to enforce access, instead of Python‚Äôs _voluntary_ underscore __convention__."
    i like that

"When tested for truth, only false and nil evaluate to a false value. Everything else is true (including 0, 0.0, "", and [])."

dict syntax
    { "one" => "eins", "two" => "zwei", "three" => "drei" }
    "hashes" not dicts

These ratings are not strings. When you place a colon in front of a simple word,
you get a symbol. Symbols are cheaper than strings (in terms of computer
memory.) If you use a word over and over in your program, use a symbol. Rather
than having thousands of copies of that word in memory, the computer will store
the symbol only once.
    :foo

working through https://try.ruby-lang.org/

.each can be called on numbers, arrays, hashes, takes a block
.select lets you filter, also takes a block

    def print_plays(year_from, year_to)
    get_shakey["William Shakespeare"]
        .select { |k, v|
        year_from <= v["finished"] &&
        year_to   >= v["finished"]
        }.each { |k, v|
        puts "#{v["title"].ljust(30)} #{v["finished"]}"
        }
    end
    print_plays(1600, 1605)

    First replace Jimmy with #{}. If Ruby sees a hash symbol # followed by a curly
    brace { it looks for a variable between the first brace and the following
    closing brace }. So we can use this: ‚ÄúHi, my name is #{name}‚Äù.

    class Blurb
    attr_accessor :content, :time, :mood

    def initialize(mood, content="")
        @time    = Time.now
        @content = content[0..39]
        @mood    = mood
    end
    end

    Blurb.new(:sick).time

so @ is basically self

    class Blurbalizer
    def initialize(title)
        @title  = title
        @blurbs = [] # A fresh clean array
                    # for storing Blurbs
    end

    def add_a_blurb(mood, content)
        # The << means add to the end of the array
        @blurbs << Blurb.new(mood, content)
    end

    def show_timeline
        puts "Blurbify: #{@title} has #{@blurbs.count} Blurbs"

        @blurbs.sort_by { |t|
        t.time
        }.reverse.each { |t|
        puts "#{t.content.ljust(40)} #{t.time}"
        }
    end
    end

    myapp = Blurbalizer.new "The Big Blurb"

so you append to a list by doing list << new_item

ok done w tryruby
let's do an aoc problem
starting 2021

ok cool day 1 part 1 ez

now let's figure out how to set up type annotations
https://betterprogramming.pub/why-i-stopped-using-sorbet-in-all-my-ruby-projects-9366bf6dd116
"code becomes bloated" lol go fuck yourself

second argument is they spent a lot of time typing all of their dependencies - just dont do that, its ok

most compelling argument is that ruby 3 had the chance to handle type annotations better but matz doesnt like type annotations
boo to matz. boo to ruby.

https://zverok.space/blog/2023-05-05-ruby-types.html
    Matz commented on the issue, saying that he acknowledges the demand but
    personally never liked the idea, basically considering annotations
    redundant, ‚Äúnot DRY.‚Äù

    BOOOOOOO
    BOOOOOOOOOOOOOO

https://sorbet.org/blog/2020/07/30/ruby-3-rbs-sorbet

getting vscode to play nice w ruby/rbenv has been a nightmare so far

maybe i'll just use asdf

ok gonna start part 2 while installing asdf

part 2 done

ok i have asdf set up

DONE get sorbet vscode extension working

ok i updated my os (i was two major os versions behind!) and messed around w various things
one of my main issues was that i was doing extend T::sig instead of extend T::Sig, whoops

so now we pass sorbet and things are looking good
i'm reading through more sorbet docs
T.must asserts something nilable is not nil

some notes on runtime check perf tricks in https://sorbet.org/docs/type-assertions

https://sorbet.org/docs/troubleshooting

https://sorbet.org/docs/faq
    long, i'll read this later

so for day 1 part 2 i have this


  sig { returns(Integer) }
  def part_two
    depths = load_input

    last_window_sum = T.must(depths[0..2]).sum
    result = 0
    depths.each_cons(3).each do |window|
      result += 1 if window.sum > last_window_sum

      last_window_sum = window.sum
    end

    result

i was hoping to see if i could use some neato zip-style approach instead of a .each forloop
let's see

ok i think this should work

  sig { returns(Integer) }
  def part_two
    depths = load_input

    windows = depths.each_cons(3).map(&:sum)

    windows.zip(T.must(windows[1..])).select do |window_one, window_two|
      !window_two.nil? && window_two > window_one
    end.count
  end

but now i'm having trouble running the program

    [jrheard@erebus:advent_2021] ÓÇ† main
    üöÇ  ruby day_1.rb
    day_1.rb:5:in `<class:Main>': uninitialized constant Main::T (NameError)

    extend T::Sig
            ^^^^^
            from day_1.rb:4:in `<main>'

    [jrheard@erebus:advent_2021] ÓÇ† main [!]
    üöÇ  bundle exec ruby day_1.rb
    day_1.rb:5:in `<class:Main>': uninitialized constant Main::T (NameError)

    extend T::Sig
            ^^^^^
            from day_1.rb:4:in `<main>'

something i've done since sitting down today must have caused an issue
or i'm not invoking the program correctly
let's figure it out

i suspect it's because of group development
    gem 'sorbet', group: :development

how can i run the program in a development group context?
no, that doesn't seem to be it

ok it looks like the issue is that i had removed this
    require 'sorbet-runtime'

so i guess that really is necessary, cool cool

also it's been bugging me that i have to wrap my code in a Main module/class to get sorbet to work
let's read https://github.com/sorbet/sorbet/pull/3491

ok cool doesn't seem necessary, ezpz
had to quiet a rubocop lint complaining about mixin usage at top level but thats ok

ok i think i'm happy with day 1 now! :)

also, TODO figure out what &:sum means here
    windows = depths.each_cons(3).map(&:sum)

it told me to do that instead of doing a block like |x| x.sum
